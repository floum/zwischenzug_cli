#!/usr/bin/env ruby

require 'thor'
require 'stockfish'
require 'net/http'

class ZwischenzugCLI < Thor
  desc 'puzzle FEN', 'determines if FEN may be a puzzle'
  def puzzle(fen)
    p Stockfish.analyze fen, multipv: 2, depth: 22
  end

  desc 'fetch ID', 'fetch puzzle ID from lichess.org'
  def fetch(id)
    uri = URI.parse "https://lichess.org/training/#{id}"
    response = Net::HTTP.start(uri.host, uri.port,   
      :use_ssl => uri.scheme == 'https') do |http|
      request = Net::HTTP::Get.new uri

      http.request request
    end

    positions = response.body.scan(/"ply":(\d+),"fen":"(\w+\/\w+\/\w+\/\w+\/\w+\/\w+\/\w+\/\w+ [wb] [-KQkq]+ [-\w]+ \d+ \d+)","id":"[^"]+","uci":"(\w+)","san":"([\w=#\+]+)"/).map {|ply, fen, uci, san| [ply.to_i, fen, uci, san]}

    initial_ply = response.body[/"initialPly":\d+/][/\d+/].to_i
    puzzle = positions.select {|position| position[0] >= initial_ply-1}

    moves = puzzle.map do |ply, fen, uci, san, index|
      [ply, san]
    end[1..-1].map do |ply, san|
      if ply.odd?
        [ply/2 + 1, '.', san].join
      else
        [san]
      end
    end.join(' ')

    puzzle_fen = puzzle[0][1]

    if puzzle_fen.split(' ')[1] == 'b'
      moves = "#{initial_ply/2}...#{moves}"
    end

    pgn = %Q([SetUp "1"]\n[FEN "#{puzzle_fen}"]\n#{moves})

    STDOUT.write pgn
  end
end

ZwischenzugCLI.start(ARGV)
